package scraper

import (
	"testing"

	"github.com/bernmarx/habrparser/app/internal/pkg/page"

	"github.com/stretchr/testify/assert"
)

func TestScrapeArticle(t *testing.T) {
	expected := page.Page{
		ID:           134836,
		Title:        "Моки и стабы",
		Article:      "Существует категория классов, которые тестировать весьма просто. Если класс зависит только от примитивных типов данных и не имеет никаких связей с другими бизнес-сущностями, то достаточно создать экземпляр этого класса, «пнуть» его некоторым образом путем изменения свойства или вызова метода и проверить ожидаемое состояние. \n\nЭто самый простой и эффективный способ тестирования, и любой толковый дизайн отталкивается от подобных классов, которые являются «строительными блоками» нижнего уровня, на основе которых затем уже строятся более сложные абстракции. Но количество классов, которые живут в такой «изоляции» не много по своей природе. Даже если мы по нормальному выделили всю логику по работе с базой данных (или сервисом) в отдельный класс (или набор классов), то рано или поздно появится кто-то, кто эти классы будет использовать для получения более высокоуровневого поведения и этого «кого-то» тоже нужно будет тестировать. \n\nНо для начала давайте рассмотрим более типичный случай, когда логика по работе с базой данных или внешним сервисом, а также логика обработки этих данных сосредоточена в одном месте. \n\n\n// Модель представления, предназначенная для управления входом \n// пользователя в систему\npublic class LoginViewModel\n{\n    public LoginViewModel()\n    {\n        // Читаем имя последнего пользователя\n        UserName = ReadLastUserName();\n    }\n\n    // Имя пользователя; может быть изменено пользователем\n    public string UserName { get; set; }\n\n    // Логиним пользователя UserName \n    public void Login()\n    {\n        // Не обращаем внимание на дополнительную логику, которая должна быть \n        // выполнена. Считаем что нам достаточно просто сохранить имя текущего\n        // пользователя\n        SaveLastUserName(UserName);\n    }\n\n    // Читаем имя последнего залогиненного пользователя\n    private string ReadLastUserName()\n    {\n        // Не важно, как она на самом деле реализована ...\n        // Просто возвращаем что-нибудь, чтобы компилятор не возражал\n        return \"Jonh Doe\";\n    }\n\n    // Сохраняем имя последнего пользователя\n    private void SaveLastUserName(string lastUserName)\n    {\n        // Опять таки, нам не интересно, как она реализована\n    }\n}\n\n\nКогда речь заходит о тестировании подобных классов, то обычно эта вью-модель помещается на форму, которая затем тестируется руками Если вместо вью-модели подобное смешивание логики происходит при реализации серверных компонент, то они тестируются путем создания простого консольного приложения, которое будет вызывать необходимые высокоуровневые функции, тестируя, таким образом, весь модуль целиком. В обоих случаях такой вариант тестирования нельзя назвать очень уж автоматическим. \n\nПРИМЕЧАНИЕ\nНе нужно бросать в меня камнями с криками «Да кто сегодня вообще такую хрень написать можно? Ведь уже столько всего написано о вреде такого подхода, да и вообще, у нас есть юнити-шмунити и другие полезности, так что это нереальный баян двадцатилетней давности!». Кстати, да, это баян, но, во-первых, речь не юнитях и других контейнерах, а о базовых принципах, а во-вторых, подобное «интеграционное» тестирование все еще невероятно популярно, во всяком случае, среди многих моих «зарубежных» коллег.\n\nСоздания «швов» для тестирования приложения\n\nДаже если не задумываться о том, какое количество новомодных принципов проектирования нарушает наша вью-модель, четко видно, что ее дизайн несколько … убог. Ведь даже если проектировать старым дедовским бучевским методом, то становится понятно, что всю работу по сохранению имени последнего пользователя, логику по работе с базой данных (или другим внешним источником данных) нужно спрятать подальше с глаз долой и сделать это «проблемой» кого-то другого и использовать уже этого «кого-то» в качестве «строительного блока» для получения более высокоуровневого поведения:\n\ninternal class LastUsernameProvider\n{ \n    // Читаем имя последнего пользователя из некоторого источника данных\n    public string ReadLastUserName() { return \"Jonh Doe\"; } \n    // Сохраняем это имя, откуда его можно будет впоследствии прочитать\n    public void SaveLastUserName(string userName) { }\n}\n \npublic class LoginViewModel\n{ \n    // Добавляем поле для получения и сохранения имени последнего пользователя\n    private readonly LastUsernameProvider _provider = \n                         new LastUsernameProvider(); \n  \n    public LoginViewModel() \n    { \n        // Теперь просто вызываем функцию нового вспомогательного класса\n        UserName = _provider.ReadLastUserName(); \n    } \n    \n    public string UserName { get; set; } \n    \n    public void Login() \n    { \n        // Все действия по сохранению имени последнего пользователя также\n        // делегируем новому классу\n        _provider.SaveLastUserName(UserName); \n    }\n}\n\n\nПока что написание модульного теста все еще остается затруднительным, но становится понятным, как можно достаточно просто «подделать» реальную реализацию класса LastUsernameProvider и сымитировать нужное для нас поведение. Достаточно выделить методы этого класса в отдельный интерфейс или просто сделать их виртуальными и переопределить в наследнике. После чего останется лишь «прикрутить» нужный нам объект в нашу вью-модель. \n\nПРИМЕЧАНИЕ\n\nЧестно говоря, я не большой фанат изменений в дизайне только ради «тестируемости» кода. Как показывает практика, нормальный ОО дизайн либо уже является достаточно «тестируемым» или же требует лишь минимальных телодвижений, чтобы сделать его таковым. Некоторые дополнительные мысли по этому поводу можно найти в заметке «Идеальная архитектура».\n\nДаже не прибегая ни к каким сторонним библиотекам для «инджекта» зависимостей мы можем сделать это самостоятельно несколько простыми способами. Нужную зависимость можно передать через дополнительный конструктор, через свойство или создать фабричный метод, который будет возвращать интерфейс ILastUsernmameProvider. \n\nДавайте рассмотрим вариант с конструктором, который является довольно простым и популярным (при небольшом количестве внешних зависимостей он работает просто прекрасно).\n\n// Выделяем методы в интерфейс\ninternal interface ILastUsernameProvider\n{ \n    string ReadLastUserName(); \n    void SaveLastUserName(string userName);\n}\n \ninternal class LastUsernameProvider : ILastUsernameProvider\n{ \n    // Читаем имя последнего пользователя из некоторого источника данных\n    public string ReadLastUserName() { return \"Jonh Doe\"; } \n    // Сохраняем это имя, откуда его можно будет впоследствии прочитать\n    public void SaveLastUserName(string userName) { }\n}\n \npublic class LoginViewModel\n{ \n    private readonly ILastUsernameProvider _provider; \n    \n    // Единственный открытый конструктор создает реальный провайдер\n    public LoginViewModel() \n        : this(new LastUsernameProvider()) \n    {} \n    \n    // \"Внутренний\" предназначен только для тестирования и может принимать \"фейк\"\n    internal LoginViewModel(ILastUsernameProvider provider) \n    { \n        _provider = provider; \n        UserName = _provider.ReadLastUserName(); \n    } \n  \n    public string UserName { get; set; } \n    \n    public void Login() \n    { \n        _provider.SaveLastUserName(UserName); \n    }\n}\n\n\nПоскольку дополнительный конструктор является внутренним (internal), то он доступен только внутри этой сборке, а также «дружеской» сборке юнит-тестов. Конечно, если тестируемые классы являются внутренними не будет не какой, но поскольку все «клиенты» внутреннего класса находятся в одной сборке, то и контролировать их проще. Подобный подход, основанный на добавлении внутреннего метода для установки «фальшивого» поведения является разумным компромиссом упрощения тестирования кода, не налагая ограничения на использования более сложных механизмов управления зависимостями, типа IoC контейнеров. \n\nПРИМЕЧАНИЕ\nОдним из недостатков при работе с интерфейсами является падение читабельности, поскольку не понятно, сколько реализаций интерфейса существует и где находится реализация того или иного метода интерфейса. Такие инструменты, как Решарпер существенно смягчают эту проблему, поскольку поддерживают не только навигацию к объявлению метода (Go To Declaration), но также и навигацию к реализации метода (Go To Implementation):\n\n\n\n\nПроверка состояния vs проверка поведения\n\nТеперь давайте попробуем написать юнит-тест вначале для конструктора класса LoginViewModel, который получает имя последнего залогиненного пользователя, а потом юнит-тест для метода Login, после выполнения которого, имя последнего пользователя должно быть сохранено. \n\nДля нормальной реализации этих тестов нам нужна «фейковая» реализация интерфейса, при этом в первом случае, нам нужно вернуть произвольное имя последнего пользователя в методе ReadLastUserName, а во втором случае – удостовериться, что вызван метод SaveLastUserName. \n\nИменно в этом и отличаются два типа «фейковых» классов: стабы предназначены для получения нужного состояния тестируемого объекта, а моки применяются для проверки ожидаемого поведения тестируемого объекта. \n\nСтабы никогда не применяются в утверждениях, они простые «слуги», которые лишь моделируют внешнее окружение тестового класса; при этом в утверждениях проверяется состояние именно тестового класса, которое зависит от установленного состояния стаба.\n\n// Стаб возвращающее указанное имя последнего пользователя\ninternal class LastUsernameProviderStub : ILastUsernameProvider\n{ \n    // Добавляем публичное поле, для простоты тестирования и \n    // возможности повторного использования этого класса\n    public string UserName; \n    \n    // Реализация метода очень простая - просто возвращаем UserName\n    public string ReadLastUserName() \n    { \n        return UserName; \n    } \n    \n    // Этот метод в данном случае вообще не интересен\n    public void SaveLastUserName(string userName) { }\n}\n \n[TestFixture]\npublic class LoginViewModelTests\n{ \n    // Тестовый метод для проверки правильной реализации конструктора вью-модели\n    [Test] \n    public void TestViewModelConstructor() \n    { \n        var stub = new LastUsernameProviderStub(); \n        \n        // \"моделируем\" внешнее окружение\n        stub.UserName = \"Jon Skeet\"; // Ух-ты!!\n        var vm = new LoginViewModel(stub); \n        \n        // Проверяем состояние тестируемого класса\n        Assert.That(vm.UserName, Is.EqualTo(stub.UserName));\n     }    \n}\n\n\nУ моков же другая роль. Моки «подсовываются» тестируемому объекту, но не для того, чтобы создать требуемое окружение (хотя они могут выполнять и эту роль), а прежде всего для того, чтобы потом можно было проверить, что тестируемый объект выполнил требуемые действия. (Именно поэтому такой вид тестирования называется behaviortesting, в отличие от стабов, которые применяются для state-basedtesting).\n\n// Мок позволяет проверить, что метод SaveLastUserName был вызван \n// с определенными параметрами\ninternal class LastUsernameProviderMock : ILastUsernameProvider\n{ \n    // Теперь в этом поле будет сохранятся имя последнего сохраненного пользователя\n    public string SavedUserName; \n    \n    // Нам все еще нужно вернуть правильное значение из этого метода,\n    // так что наш \"мок\" также является и \"стабом\"\n    public string ReadLastUserName() { return \"Jonh Skeet\";} \n    \n    // А вот в этом методе мы сохраним параметр в SavedUserName для \n    public void SaveLastUserName(string userName) \n    { \n        SavedUserName = userName; \n    }\n}\n \n// Проверяем, что при вызове метода Login будет сохранено имя последнего пользователя\n[Test]\npublic void TestLogin()\n{ \n    var mock = new LastUsernameProviderMock(); \n    var vm = new LoginViewModel(mock); \n    \n    // Изменяем состояние вью-модели путем изменения ее свойства\n    vm.UserName = \"Bob Martin\"; \n    // А затем вызываем метод Login\n    vm.Login(); \n    // Теперь мы проверяем, что был вызван метод SaveLastUserName\n    Assert.That(mock.SavedUserName, Is.EqualTo(vm.UserName));\n}\n\n\nА зачем мне знать об этих отличиях?\n\nДействительно, разница в понятиях может показаться незначительной, особенно если вы реализуете подобные «фейки» руками. В этом случае знание этих паттернов лишь позволит говорить с другими разработчиками на одном языке и упростит наименование фейковых классов. \n\nОднако рано или поздно вам может надоесть это чудесное занятие по ручной реализации интерфейсов и вы обратите свое внимание на один из Isolation фреймворков, таких как Rhino Mocks, Moq или Microsoft Moles. Там эти термины встретятся обязательно и понимание отличий между этими типами фейков вам очень пригодится. \n\nЯ осознанно не касался ни одного из этих фреймворков, поскольку каждый из них заслуживает отдельной статьи и ИМО лишь усложнит понимание этих понятий. Но если вам все же интересно посмотреть на некоторые из этих фреймворков более подробно, то об одном из них я писал более подробно: “Microsoft Moles”.",
		Posted:       "2011-12-19T04:57:17.000Z",
		Author:       "SergeyT",
		CommentCount: 14,
		Rating:       33,
	}
	got := ScrapeArticle("https://habr.com/ru/post/134836/")
	assert.Equal(t, expected, got)
}
